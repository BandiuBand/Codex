Технічна специфікація (1 сторінка): Chat-Agent + Backend + Frontend (без сесій, agent-first, без “origin” на старті)
0) Мета

Забезпечити канал взаємодії користувач ↔ система агентів через єдиний глобальний Chat, який:

існує незалежно від UI (живе з моменту старту сервера);

дозволяє агенту писати першим (agent-first);

не використовує сесій і не має “зворотньої адреси” до першого user-повідомлення;

накопичує повідомлення в RAM (історія поточної роботи сервера).

1) Компоненти
1.1 Chat-Agent (серверний агент-брідж)

Відповідальність:

зберігати history в RAM;

приймати повідомлення від агентів і від користувача;

забезпечувати механізм “питання → очікування відповіді” для агентів.

Chat-Agent НЕ:

не створює/не веде сесії;

не зберігає/не відновлює історію з диску;

не виконує інструментальні дії (read/write/list/run) — лише маршрутизує до інших агентів, якщо так задумано архітектурою.

1.2 Backend (HTTP + опційно SSE/WS)

Відповідальність:

API для UI: читати історію / надсилати повідомлення;

(опційно) пушити нові повідомлення UI через SSE/WS, якщо підключений.

1.3 Frontend (Web Chat Page)

Відповідальність:

показувати history;

надсилати user-повідомлення;

працювати як “вікно” в Chat, не впливаючи на існування Chat.

2) Дані та структури
2.1 Message

Обов’язкові поля:

id (монотонний int або UUID)

ts (timestamp)

role: "agent" | "user" | "system"

author: string (наприклад AdaptiveAgent, ChatAgent, user)

text: string (порожні/пробіли заборонені)

meta (optional): { reply_to?: message_id, tags?: string[] }

2.2 ChatState (в RAM)

history: Message[]

pending_input: null | { requested_by: string, question_msg_id: id }

waiters: queue/promise (механізм пробудження агентів, які чекають відповіді)

subscribers (опційно, якщо SSE/WS): набір активних підключень для пуша

3) Контракт Chat-Agent (внутрішній API для інших агентів)
3.1 Методи

post_agent(author, text, meta?) -> message_id

додає повідомлення в history

пушить підписникам (якщо є)

не потребує “origin”

post_user(text) -> message_id

валідує text (trim; якщо пусто — reject)

додає в history

пушить підписникам (якщо є)

якщо pending_input != null → це вважається відповіддю і пробуджує wait_user()

ask_user(author, question_text) -> message_id

еквівалент post_agent(...) + встановлює pending_input = {requested_by: author, question_msg_id}

після цього агент, який викликав, має перейти у wait_user()

wait_user() -> user_text

блокується логічно (через promise/queue) до приходу post_user

повертає текст user-повідомлення

скидає pending_input (тільки якщо відповідь була до активного pending)

3.2 Інваріанти

Chat-Agent завжди приймає agent-повідомлення, навіть якщо UI не підключений.

Жодних сесій. Chat один на сервер.

“Зворотньої адреси” не існує як обов’язкового поняття. Доставка в UI = через читання history або пуш підписникам.

4) Backend API для UI
4.1 Мінімальний polling-варіант (обов’язковий)

GET /chat/history?after=<id>

Повертає масив повідомлень з history, де id > after

Якщо after відсутній → повертає останні N (наприклад 100)

POST /chat/user_message

Body: { "text": "..." }

Сервер: trim → якщо пусто → HTTP 400

Викликає ChatAgent.post_user(text)

4.2 SSE/WS (опційно)

GET /chat/stream (SSE) або WS endpoint

При підключенні:

може одразу надіслати останні N повідомлень

далі пушить всі нові повідомлення

Важливо: це не сесія, це лише канал доставки.

5) Логіка AdaptiveAgent (критично, щоб не було “пустого запуску”)
5.1 Старт/тригер

AdaptiveAgent НЕ запускає виконання “сам по собі” з пустим input.
Дозволені тригери:

user_message (прийшов текст від користувача)

внутрішній сигнал від іншого агента (якщо є такий режим)

5.2 Патерн “запитати → чекати”

Якщо AdaptiveAgent потребує даних:

chat.ask_user("AdaptiveAgent", "Питання...")

answer = chat.wait_user()

продовжити планування/виконання

Заборонено:

запуск плану з "" / null input

“імітувати” user-ввід

6) Поведінка Frontend (UI)

При відкритті сторінки:

почати polling GET /chat/history?after=last_id (або підключити SSE/WS)

відображати повідомлення в порядку id

На send:

POST /chat/user_message {text}

UI не створює чат, не запускає “сесію”, не ініціалізує “origin”.

7) Перевірки/тести (мінімум)

Сервер стартує, UI НЕ відкритий: агент пише повідомлення → воно в history.

UI відкрили пізніше: GET history показує те повідомлення.

Агент викликає ask_user і переходить у wait_user: нічого не виконується далі, поки не прийде POST user_message.

POST user_message з пустим текстом → 400, у history не додається.

Після відповіді користувача агент продовжує з цією відповіддю, без “пустих запитів”.

8) Нотація поведінки блокування
- Якщо AdaptiveAgent запитує уточнення, Chat-Agent зберігає питання у history і чекає поста користувача через post_user; наступні кроки не виконуються, доки не з’явиться текст.
- Порожні або пробільні повідомлення не вважаються подією: вони відхиляються бекендом і не додаються до history, тож агент не прокидається та не переходить до обробки.
